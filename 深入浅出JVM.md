## 深入理解JVM

首先声明以下分析是以HotSpot虚拟机为说明对象，其他虚拟机产品会有差别

##### 内容大纲：首先列出需要额外关注的点基本涵盖了jvm绝大部分内容

- 64位虚拟机与32位虚拟

- 程序编译与代码优化
  - 编译器优化 C1
    - 了解javac源码（java写的前端编译器，将源码转换为字节码）
    - 各种语法糖
      - 泛型（字节码类型擦除），自动装箱拆箱
  - 运行期优化 C2
    - JIT编译器将字节码转换为机器码
      - 哪些是热点代码？①多次被调用的方法；②方法内多次循环执行的循环体
      - 热点代码的2种探测方式：①采样方式(定期采集栈顶执行方法)；②方法调用计数

- 虚拟机执行子系统
  
  - 类文件结构(主要记住几个关键的结构)
  - **虚拟机加载机制**
    - 记忆宫殿法则7个字：家(加载)宴(验证)准(准备)解(解析)初(初始化)使(使用)蟹(卸载)
  - 虚拟机字节码执行引擎
  
- 自动内存管理机制
  
  - 运行时数据区域
  - GC相关
    - 垃圾收集算法
    - **垃圾收集器GC**
    - 内存分配与回收策略
  
- 高效并发
  - **java内存模型**与线程
  - 线程安全与锁优化
  
- 监控与故障处理
  - jdk工具
    - jps
    - jstat
    - jinfo
    - jmap
    - jhat
    - jstack
    - jConsole可视化
    - VisualVM可视化
  - 调优案例与实战



### 虚拟机执行子系统

#### class文件结构

class文件是一组以字节(8位)为基础的二进制流

class文件属于一种数据结构，类似于C中结构体。

类型只包含2种：无符号整数(u1,u2,u4,u8可以用来表示数字，索引引用，数值，utf编码的字符串)以及table类型(组合数据类型)，本质上整个class文件就是一个table。

<img src="/Users/songke/work/TecPorter/imges/class文件结构.png" style="zoom: 50%;" />

通过记忆宫殿记忆住class文件的格式以及顺序

```
一个会魔法的女人去一个魔法村探险，
她和老婆一样发音不标准把吃经常说成ci，
每天吃的是版本，而且是煮着吃的。
刚到这个村入口就看到个招牌上写着前面有多个温泉大池子，又往前走了2分钟，确实发现了好多咕嘟咕嘟冒气泡的温泉池子。
于是她就想走近去试一下这些池子的水，走近一看，池子前都有访问标记，禁止触摸。
于是继续往前走，又走了2分钟，说了一句，我当前是真的累啊！
可是周围没有歇脚地方，就继续走了2分钟，又说了句：真是超级累啊！
紧接着又走了2分钟，感觉口渴的不行，发现一个水房，上面画了好多个水龙头，进去一看一望无际的水龙头都在不停地流着水。
喝饱了后继续走了2分钟，看到有好多个田地的标记，往远处一看，一望无尽的田野尽收眼底。
正在看时，突然一个老爷爷老了，说他老子这个村子名叫小方。于是我问他你们村有几个叫小方的，他说有好多个，没一会儿所有的小方都被叫了过来。
没敢耽搁继续走，终于走到村子入口的大牌坊。
牌坊隐约看见有好多个题字署名，凑近一看各种名人的名字都在牌坊上，
更神奇的是自己的名字竟然清晰地写在最前面，女人边奇怪，边思考走进了这个神奇魔法村。

```



#### 常量表（各种常量表）

字面量：字符串或者被final修饰的变量

符号引用：编译时用到的信息，主要是字段方法类以及接口等的元信息；这里涉及动态连接，jvm运行时首先会获得符号引用，在类创建或者运行时会将符号引用转换为具体的内存地址。

#### 常量池（Constant_Value）

<img src="/Users/songke/work/TecPorter/imges/constant_value结构.png" style="zoom:80%;" />



#### 字段表

三种字符串

- 简单名称
- 完全限定名
- 描述符



#### 属性表集合

在class文件，字段表，方法表中都可以携带属性表集合，以便表示特殊场景下专有信息

不再严格要求顺序性，可以自定义属性

<img src="/Users/songke/work/TecPorter/imges/虚拟机规范定义的属性.png" style="zoom:50%;" />

##### code属性结构

<img src="/Users/songke/work/TecPorter/imges/code属性表结构.png" style="zoom:50%;" />



#### 类加载器

实现给定类的完全限定名找到其class文件并加载到内存的功能组件

##### 分类

- 启动类加载器bootstrap classloader（c++编写，是jvm的一部分，加载lib目录下jar包）
- 扩展类加载器ext classloader（java编写，加载ext目录中jar包）
- 应用程序类加载器applicacation classloader(系统类加载器，java编写，加载classpath目录下文件)



##### 类与类加载器关系：

类的比较首先比较是否是同一个类加载器加载的，如果不是同一个类加载的即便是相同类也是不相等的，类比较结果都是false

包括equals,instanceof ,isAssignableFrom等等



##### 双亲委派模式

- 并不是强制性的，仅仅是推荐的一种实现方式而已

- class伴随着类加载器一起具备了带有优先级的层次关系
- 保证java程序的稳定性，

##### 双亲委派模式破坏

1. 提供了`` protected Class<?> loadClass(String name, boolean resolve)``方法供子类可以实现，可以破坏破模式

2. 线程上下文类加载器thread context classloader：基础类调用用户类的代码

3. 为了实现热部署，热加载

   ```
   （典型的实现是OSGI：open servie gateway Initiative为java提供动态模块化的系统）
   每个模块都有属于自己的classpath和类加载器，模块之间通过包暴露和引入进行关联，每个模块有着自己独立的生命周期，我们可以动态地对模块进行加载、卸载、更新
   
   ```

   

#### 字节码执行引擎

##### 运行时数据栈帧结构

- 局部变量表，
- 操作数栈
- 动态连接：每个栈帧都包含一个执行运行时常量池中该栈帧所属方法的引用
- 返回地址

提高一个实际问题：SLOT变量虽然超出作用域但是无法得到有效的释放内存问题？？

主要是后续没有对此Slot再次使用，未被覆盖，当前gc roots依然有效，未被gc。

主动进行 变量=null的设置，有时候是有意义的，但是绝大多数情况下是没有必要的。





































